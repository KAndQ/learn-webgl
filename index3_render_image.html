<html>
    <head></head>
    <script src="./buildin.js"></script>
    <body>
        <canvas id="c" width="640" height="480"></canvas>
        <script>
            function render(image) {
                console.log("load image");

                var canvas = document.querySelector("#c");
                var gl = canvas.getContext("webgl2");
                if (!gl) {
                    console.log("no webgl");
                    return;
                }

                var vertexShaderSource = `#version 300 es
precision highp float;

in vec2 a_texCoord;
in vec2 a_position;
uniform vec2 u_resolution;
out vec2 v_texCoord;

void main() {
  vec2 zeroToOne = a_position / u_resolution;
  vec2 zeroToTwo = zeroToOne * 2.0;
  vec2 clipSpace = zeroToTwo - 1.0;
  gl_Position = vec4(clipSpace, 0, 1);
  v_texCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y);
}
`;

                var fragmentShaderSource = `#version 300 es
precision highp float;

in vec2 v_texCoord;
uniform sampler2D u_image;
out vec4 outColor;

void main() {
    vec2 onePixel = vec2(1.0) / vec2(textureSize(u_image, 0));
    outColor = texture(u_image, v_texCoord);
//   outColor = texture(u_image, v_texCoord).bgra;
    // outColor = (texture(u_image, v_texCoord) + texture(u_image, v_texCoord + vec2(-onePixel.x, 0)) + texture(u_image, v_texCoord + vec2(onePixel.x, 0))) / 3.0;
}
`;
                var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                var program = createProgram(gl, vertexShader, fragmentShader);

                var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
                var texCoordAttributeLocation = gl.getAttribLocation(program, "a_texCoord");
                var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                var imageLocation = gl.getUniformLocation(program, "u_image");

                var vao = gl.createVertexArray();

                // provide texture coordinates for the rectangle.
                gl.bindVertexArray(vao);
                var texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
                setRectangle(gl, 0, 0, 1, 1);
                gl.enableVertexAttribArray(texCoordAttributeLocation);
                var size = 2; // 2 components per iteration
                var type = gl.FLOAT; // the data is 32bit floats
                var normalize = false; // don't normalize the data
                var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
                var offset = 0; // start at the beginning of the buffer
                gl.vertexAttribPointer(texCoordAttributeLocation, size, type, normalize, stride, offset);

                // Create a texture.
                var texture = gl.createTexture();

                // make unit 0 the active texture uint
                // (ie, the unit all other texture commands will affect
                gl.activeTexture(gl.TEXTURE0 + 0);

                // Bind it to texture unit 0' 2D bind point
                gl.bindTexture(gl.TEXTURE_2D, texture);

                // Set the parameters so we don't need mips and so we're not filtering
                // and we don't repeat
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                // Upload the image into the texture.
                var mipLevel = 0; // the largest mip
                var internalFormat = gl.RGBA; // format we want in the texture
                var srcFormat = gl.RGBA; // format of data we are supplying
                var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
                gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, image);

                gl.bindVertexArray(vao);
                var positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                setRectangle(gl, 8, 8, image.width, image.height);
                // var offset = { x: 50, y: 50 };
                // gl.bufferData(
                //     gl.ARRAY_BUFFER,
                //     new Float32Array([
                //         offset.x,
                //         offset.y,
                //         offset.x + image.width,
                //         offset.y,
                //         offset.x,
                //         offset.y + image.height,
                //         offset.x,
                //         offset.y + image.height,
                //         offset.x + image.width,
                //         offset.y,
                //         offset.x + image.width,
                //         offset.y + image.height,
                //     ]),
                //     gl.STATIC_DRAW
                // );
                gl.enableVertexAttribArray(positionAttributeLocation);
                var size = 2; // 2 components per iteration
                var type = gl.FLOAT; // the data is 32bit floats
                var normalize = false; // don't normalize the data
                var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
                var offset = 0; // start at the beginning of the buffer
                gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

                // Tell WebGL how to convert from clip space to pixels
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                // Clear the canvas
                gl.clearColor(1, 1, 0, 0.5);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Tell it to use our program (pair of shaders)
                gl.useProgram(program);

                // Pass in the canvas resolution so we can convert from
                // pixels to clip space in the shader
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

                // Tell the shader to get the texture from texture unit 0
                gl.uniform1i(imageLocation, 0);

                // Draw the rectangle.
                var primitiveType = gl.TRIANGLES;
                var offset = 0;
                var count = 6;
                gl.drawArrays(primitiveType, offset, count);
            }

            function main() {
                var image = new Image();
                image.src = "./leaves.jpg";
                image.onload = function () {
                    render(image);
                };
                image.onerror = function (e) {
                    console.error(e);
                };
            }
            main();
        </script>
    </body>
</html>
